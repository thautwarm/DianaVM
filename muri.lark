%mkrepl

NAME: /[a-zA-Z_\u4e00-\u9fa5][a-zA-Z0-9_\u4e00-\u9fa5]*?/

%%
from contextlib import contextmanager
from dianascript.operator_resolve import Operator, binop_reduce

def cons(op):
    def ap(l, r):
        loc, opname = op
        return EOp(l, opname, r)
    return ap

def resolve_binop(args):
    if len(args) == 1:
        return args[0]

    for i in range(1, len(args), 2):
        assert isinstance(args[i], tuple)
        op = args[i]
        args[i] = Operator(op[1], op)
    return binop_reduce(cons, args)

def append(xs, x):
    xs.append(x)
    return xs

BLOCKS = [[]]

def enter_block():
    global BLOCKS
    BLOCKS.append([])

def emit(x):
    BLOCKS[-1].append(x)

%%


list{sep, e} : list{sep, e} e  -> append($1, $3)
             |  -> []

seplist{sep, e} : seplist{sep, e} sep e  -> append($1, $3)
                | -> []

# enter block 1
eblock :  -> enter_block()

name : NAME -> *1

func : "func" name "(" arglist ")" block "end" ->  SFunc($2, $4, $6) | @1
block : list{stmt}                             ->  $1

stmt :   "var" seplist{",", name}              -> SDecl($2) | @1
       | id ":=" expr                          -> SAssign($1, $3) | @2
        | expr                                 -> SExpr($1)
       | "loop" block "end"                    -> SWhile($2) | @1
       | "for" lhs "in" expr "do" block "end"  -> SFor($2, $4, $6) | @1
       | "del" seplist{",", id}                -> SDel($2) | @1
       | "if" expr "then" block "end"          -> SIf($2, $4, None) | @1
       | "if" expr "then" block "else" block "end" -> SIf($2, $4, $6) | @1
       | "break"                                   -> SBreak()
       | "continue"                                -> SContinue()


expr :  bool_expr

or_expr : or_expr "or" and_expr -> EOr($1, $2) | @1
        | and_expr              -> $1

and_expr : and_expr "and" not   -> EAnd($1, $2) | @1
         | not                  -> $1


binop1 : ("<" | ">" |">=" | "<=" | "=" | "==" | "!=" | "in" | \
          "+" | "-" | "*" | "/" | "//" | "%" |\
          "&" | "|" | "<<" | ">>") -> (@1, *1)

binop2 : "not" "in" -> (@1, *1 + "_" + *2)

binop : (binop1 | binop2) -> $1
bin : atom (binop atom)*  -> resolve_binop(__args)

not : 'not' binop -> ENot($2) | @1
    | binop       -> $1

trailer : "," -> True
        |     -> False

lhs  : NAME                  -> LVar(*1) | @1
     | atom "." "[" expr "]" -> LIt($1, $4) | @2
     | atom "." name         -> IAttr($1, $3) | @2

pair : expr ":" expr         -> ($1, $3)

atom : atom "." "[" expr "]" -> EIt($1, $4) | @1
     | atom "." name         -> EAttr($1, $3) | @2
     | atom "(" seplist{",", expr} ")"    -> EApp($1, $3) | @2
     | "[" seplist{",", expr} trailer "]" -> EList($2) | @1
     | "(" seplist{",", expr} trailer ")" -> EPar($2, $3) | @1
     | "{" seplist{",", pair} trailer "}" -> EDict($2, $3) | @1
     | number                             -> EVal(eval(*1)) | @1
     | string                             -> EVal(eval(*1)) | @1
     | "None"    -> EVal(None) | @1
     | "True"    -> EVal(True) | @1
     | "False"   -> EVal(False) | @1
     | NAME      -> EVar(*1)    | @1
     | "-" atom  -> ENeg($2)    | @1
     | "~" atom  -> EInv($2)    | @1
     

string: (STRING | LONG_STRING) -> $1


number: (DEC_NUMBER | HEX_NUMBER | BIN_NUMBER | OCT_NUMBER | FLOAT_NUMBER | IMAG_NUMBER) -> $1
DEC_NUMBER: /0|[1-9][\d_]*/i
HEX_NUMBER.2: /0x[\da-f]*/i
OCT_NUMBER.2: /0o[0-7]*/i
BIN_NUMBER.2 : /0b[0-1]*/i
FLOAT_NUMBER.2: /((\d+\.[\d_]*|\.[\d_]+)([Ee][-+]?\d+)?|\d+([Ee][-+]?\d+))/
IMAG_NUMBER.2: /\d+[Jj]/ | FLOAT_NUMBER /[Jj]/
STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
LONG_STRING: /[ubf]?r?(""".*?(?<!\\)(\\\\)*?"""|'''.*?(?<!\\)(\\\\)*?''')/is
