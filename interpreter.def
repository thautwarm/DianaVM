// obj SrcLocTree Ptr
// check not empty
// create xxx of { a = b }

FuncMeta
    is_vararg: bool
    narg: int
    freeslots: array<int>
    fname: intern<str>
    modname: intern<str>
    filename: str
    srcLocTree : SrcLocTree
    

Stmt = {
    FunctionDef(metadata: FuncMeta, code: Ptr)
    semantic
    if check not empty metadata.freeslots
            x1 = create array of obj{
                size = metadata.freeslots.Length
            }
            for i in 1..metadata.freeslots.Length{
                x2 = item i from metadata.freeslots
                x1[i] = access local variable from slot
            }
            x3 = create obj:function {
                freevals = x1
                metadata = metadata
                code = code
            }
            push x3 to valuestack
    else
        x3 = create obj:function {
            freevals = null
            metadata = metadata
            code = code
        }
        push x3 to valuestack
    end
    end
    Return(value: Ptr) semantic
        eval value
        pop valuestack to x1
        pop callstack
        peek callstack to bigframe
        use bigframe as frame
        push x1 to valuestack
    end
    Del$Name(v: variable) from { Global Local Deref } semantic
        store null to variable v    
    end
    DeleteItem(value: Ptr, item: Ptr) semantic 
        eval value
        eval item
        pop valuestack to x_item
        pop valuestack to x_value
        extern:op_DeleteItem(x_value, x_item)
    end
    Assign(targets: Ptr[], value: Ptr) semantic
        eval value
        for _ in 1..targets.Length{
            push x1 to valuestack
        }
        for each in targets{
            eval each
        }
    end 
    $Assign(target: Ptr, value: Ptr) from {
        Add Sub Mut TrueDiv FloorDiv Mod Pow LShift RShift BitOr BitAnd BitXor
    } semantic
        eval target
        eval value
        pop valuestack to x_op2
        pop valuestack to x_op1
        x_res = extern.op_$(x_op1, x_op2) (check exception)
        push x_res to valuestack
    end

    For(target: Ptr, iter: Ptr, body: Ptr) semantic
        eval iter
        peek to x1

        eval target
        eval value
        pop valuestack to x_op2
        pop valuestack to x_op1
        x_res = extern.op_$(x_op1, x_op2) (check exception)
        push x_res to valuestack
    end
    While(cond: Ptr, body: Ptr)
    If(cond: Ptr, then: Ptr, orelse: Ptr)
    With(expr: Ptr, body: Ptr)
    Raise(value: Ptr)
    RaiseFrom(value: Ptr, from_: Ptr)
    Try(body: Ptr, err_slot: int, except_handlers: Ptr, final_body: Ptr)
    Assert(value: Ptr)
    ExprStmt(value: Ptr)
    Control(kind: int) // break, continue, reraise
    Block(stmts: Ptr[])
}

// RHS case: (Frame) -> DObj
// LHS case: (Frame, DObj) -> void

Expr = {

    $Op(left: Ptr, right: Ptr) from {
        Add Sub Mut TrueDiv FloorDiv Mod Pow LShift RShift BitOr BitAnd BitXor
    }
    $Binder(slot: int) from { Global Local Deref }
    $Op(left: Ptr, right: Ptr) from {And Or}
    $Op(value: Ptr) from { Invert Not }
    Lambda(frees : int[], code: int)
    IfExpr(cond: Ptr, then: Ptr, orelse: Ptr)
    Dict(keys: Ptr[], values: Ptr[])
    Set(elts: Ptr[])
    List(elts: Ptr[])
    Generator(target: Ptr, iter: Ptr, body: Ptr)
    Comprehension(adder: Ptr, target: Ptr, iter: Ptr, body: Ptr)
    Call(f: Ptr, args: Ptr)
    Format(format: int, args: Ptr)
    Const(constInd: int)

    Attr(value: Ptr, attr: int)
    $Name(slot: int) from { Global Local Deref }
    Item(value: Ptr, item: Ptr)
    Tuple(elts: Ptr[])
} 


// Arg(Frame) -> DObj
Arg = {
    // lhs expr

    $NameOut(ind: int) from { Global Local Deref }
    ItemOut(value: Ptr, item: Ptr)
    AttrOut(value: Ptr, attr: int)
    Val(value: Ptr)
}

// ExceptHandler(Frame, exc: Exception) -> bool
ExceptHandler = {
    // assign_slot = -1 no store
    ArbitraryCatch(assign_slot: int, body: Ptr)
    TypeCheckCatch(type: Ptr, assign_slot: int, body: Ptr)
}