// begin
using System;
using System.Collections.Generic;

namespace DianaScript
{
    using NameSpace = Dictionary<InternString, DObj>;
    using static @__TOKEN;
    using static @__VMHelper;

    public static class @__VMHelper
    {
        public static void check_argcount(DFunc f, int argcount)
        {
            if (argcount >= f.narg)
                return;
            string f_repr = ((DObj)f).__repr__;
            var expect = (f.is_vararg ? ">=" : "") + $"{f.narg}";
            throw new ArgumentException($"{f_repr} takes expect {expect} arguments, got {argcount}.");
        }
    }
    public enum @__TOKEN
    {
        RETURN,
        GO_AHEAD,
        LOOP_BREAK,
        LOOP_CONTINUE
    }

    public struct @__MiniFrame
    {
        public int blockind;
        public int offset;

        public int metadataInd;

    }


    public partial class @__DVM
    {

        // stack of (blockind, offset)
        public Stack<@__MiniFrame> errorFrames;

        public DFlatGraphCode flatGraph;

        public static DFlatGraphCode FlatGraph; // should be the same as the instance field

        public @__DVM(DFlatGraphCode flatGraph)
        {
            this.flatGraph = flatGraph;
            DVM.FlatGraph = flatGraph;
            this.errorFrames = new Stack<@__MiniFrame>();
        }

        public DObj exec_func(DFunc dfunc, DObj[] vstack)
        {
            var executor = new @__BlockExecutor
            {
                virtual_machine = this,
                offset = 0,
                token = (int)GO_AHEAD,
                vstack = vstack,
                cur_func = dfunc,
                @return = null,
                flatGraph = flatGraph
            };
            executor.exec_block(dfunc.body);
            if (executor.@return == null)
                return MK.Nil();
            return executor.@return;
        }
    }


    // like frame
    public partial class @__BlockExecutor
    {

        public @__DVM virtual_machine;
        public int offset;
        public int token;
        public DFunc cur_func;
        public DObj[] vstack;
        public DObj @return;
        public DFlatGraphCode flatGraph;

        public const int bit_nonlocal = 0b01;
        public const int bit_classify = 0b01 << 1;

        DRef loadref(int slot)
        {
            if ((slot & bit_nonlocal) == 0) // slot & bit_classify must be true
                return vstack[slot >> 2] as DRef;
            else
                return cur_func.freevals[slot >> 2];
        }

        DObj loadconst(int slot)
        {
            return flatGraph.dobjs[slot];
        }

        DObj loadvar(int slot)
        {
            DObj c;
            if ((slot & bit_nonlocal) == 0) 
            {
                if ((slot & bit_classify) == 0)
                    c = vstack[slot >> 2]; // local
                else
                {
                    DRef r = vstack[slot >> 2] as DRef; 
                    c = r.cell_contents; // local cell
                    
                }
                if (c == null)
                {
                    var name = flatGraph.funcmetas[cur_func.metadataInd].localnames[slot >> 2];
                    throw new NullReferenceException($"undefined variable {name}.");
                }
            }
            else
            {
                if ((slot & bit_classify) == 0) // freevals
                {
                    c = cur_func.freevals[slot >> 2].cell_contents; 
                    if (c == null)
                    {
                        var name = flatGraph.funcmetas[cur_func.metadataInd].freenames[slot >> 2];
                        throw new NullReferenceException($"undefined cell variable {name}.");
                    }
                }
                else // global
                {
                   c = cur_func.nameSpace[flatGraph.internstrings[slot >> 2]];
                    
                }
            }
            return c;
        }
        

        void storevar(int slot, DObj o)
        {
            if ((slot & bit_nonlocal) == 0) 
            {
                if ((slot & bit_classify) == 0)
                    vstack[slot >> 2] = o; // local
                else
                {
                    DRef r = vstack[slot >> 2] as DRef; 
                    r.cell_contents = o; // local cell
                    
                }
            }
            else
            {
                if ((slot & bit_classify) == 0) // freevals
                {
                    cur_func.freevals[slot >> 2].cell_contents = o; // local
                }
                else // global
                {
                   cur_func.nameSpace[flatGraph.internstrings[slot >> 2]] = o;
                    
                }
            }
        }

        FuncMeta loadmetadata(int slot) => flatGraph.funcmetas[slot];
        string loadstr(int slot) => flatGraph.strings[slot];
        InternString loadistr(int slot) => flatGraph.internstrings[slot];
        void set_return(DObj val) => @return = val;
        DObj[] create_vstack(DFunc func, int[] s_args)
        {
            var locals = new DObj[func.nlocal];
            for (var i = 0; i < func.narg; i++)
            {
                locals[i] = loadvar(s_args[i]);
            }
            if (func.is_vararg)
            {
                var vararg = new DObj[s_args.Length - func.narg];
                for (var i = func.narg; i < s_args.Length; i++)
                {
                    vararg[i - func.narg] = loadvar(i);
                }
                locals[func.narg] = DTuple.Make(vararg);
            }
            return locals;
        }
        public void exec_block(int blockind)
        {
            int old_offset = offset;
            var codes = flatGraph.blocks[blockind].codes;
            try
            {
                for (var i = 0; i < codes.Length; i++)
                {
                    offset = i;
                    exec_code(codes[i]);
                    if (token != (int)GO_AHEAD)
                        return;
                }
            }
            catch
            {
                virtual_machine.errorFrames.Push(new @__MiniFrame { 
                    metadataInd = cur_func.metadataInd,
                    blockind = blockind,
                    offset = offset
                });
                throw;
            }
        }
        public void assert(bool val, DObj msg)
        {
            if (!val)
                throw new Exception("assertion failed" + msg.__str__);
        }
        public void exec_code(Ptr curPtr)
        {
            //REPLACE
        }
    }
}
